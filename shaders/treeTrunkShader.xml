<?xml version="1.0" encoding="utf-8"?>

<CustomShader version="5">
    <Groups>
        <Group name="customParallax" define="CUSTOM_PARALLAX" />
    </Groups>
    <Parameters>
        <Parameter name = "windSnowLeafScale" target = "windSnowLeafScale" type = "float4" group = "base" defaultValue = "1.0 1.0 1.0 0"   minValue = "0.0 0.0 0.0 0"     maxValue = "1.0 1.0 1.0 10000.0"/>
        <Parameter name = "markerPosScaleRot" target = "markerPosScaleRot" type = "float4" group = "base" defaultValue = "0.0 0.0 0.0 0.0" minValue = "-5.0 -1.0 0.0 0.0" maxValue = "5.0 10.0 5.0 6.2832"/>
        <Parameter name = "markerColorScale"  target = "markerColorScale"  type = "float4" group = "base" defaultValue = "1.0 0.0 0.0 1.0" minValue = "0.0 0.0 0.0 0.0"   maxValue = "1.0 1.0 1.0 1.0"/>
    </Parameters>
    <UvUsages/>
    <Textures>
        <Texture name = "mMarker"       group="base"           defaultColorProfile = "sRGB"      defaultFilename = "$data/shared/default_alpha.png"/>
        <Texture name = "mParallaxMap"  group="customParallax" defaultColorProfile = "linearRGB" defaultFilename = "$data/shared/default_height.png"/>
    </Textures>
    <VertexAttributes/>
    <Variations>
        <Variation name = "customParallax" groups="base customParallax" />
    </Variations>
    <LodLevel startDistance="0">
        <CodeInjections>
            <CodeInjection position="SHARED_START">
<![CDATA[
#if defined(CUSTOM_PARALLAX)
    #define PARALLAX_MAP
#endif
]]>
            </CodeInjection>
            <CodeInjection position="OBJECT_PARAMETERS">
<![CDATA[
/*
    Meant to be used when tree is cut
    windSnowLeafScale.x - wind intensity * this value
    windSnowLeafScale.y - snow intensity * this value
    windSnowLeafScale.z - 1 - leaves are visible, 0 - no leaves
    windSnowLeafScale.w - if this value > 0.0 
                          this value replaces (pos.x + pos.y + pos.z) 
                          for colorTint and timeOffset
*/
float4 windSnowLeafScale;
/*
    markerPosScaleRot.x - horizontal uv offset ( in most cases should be 0.0 )
    markerPosScaleRot.y - vertical uv offset
    markerPosScaleRot.z - uv scale
    markerPosScaleRot.w - uv rotation around the trunk
*/
float4 markerPosScaleRot;
/*
    markerColorScale.rgb - multiplied with mMarker.rgb
    markerColorScale.a   - erosion value from mMarker.rgb
*/
float4 markerColorScale;
]]>
            </CodeInjection>
            <CodeInjection position="LIB_FUNCTION">
<![CDATA[
// Custom pixel/vertex functions
#include "$data/shaders/sharedFunctions.gsl"
// Extra functions related to the treeTrunkShader only
]]>
            </CodeInjection>
            <CodeInjection position="LIB_FUNCTION_VS">
<![CDATA[
// Custom vertex functions
#include "$data/shaders/sharedFunctions_vs.gsl"
// Extra functions related to the treeTrunkShader only
]]>
            </CodeInjection>
            <CodeInjection position="VS_OUTPUT">
<![CDATA[
    float3 localPosition : TEXCOORDn;
]]>
            </CodeInjection>
            <CodeInjection position="POST_SET_TEXCOORDS_VS">
<![CDATA[
    Out.localPosition = In.position.xyz;
]]>
            </CodeInjection>
            <CodeInjection position="POST_GET_WORLD_POSE_VS">
<![CDATA[
float windStrength = cShared0*object.windSnowLeafScale.x;
#if !defined(DEPTH_VIS) // avoid shadow artefacts by not animating in the shadow map
    if (windStrength > 0.0001) {
        TrunkOffsetStruct trunkOffsetPacked = getTrunkAnimationOffset(In,instance,object,cTime_s,windStrength);
        TrunkOffsetStruct prevTrunkOffsetPacked = getTrunkAnimationOffset(In,instance,object,cPrevTime_s,windStrength);
        // current pos
        worldPosition += trunkOffsetPacked.trunkOffset;
        // previous pos
        prevWorldPosition += prevTrunkOffsetPacked.trunkOffset;
    }
#endif
]]>
            </CodeInjection>
            <CodeInjection position = "GET_BUMP_HEIGHT_AT_WITH_GRAD_FS">
<![CDATA[
#if defined(CUSTOM_PARALLAX)
    return tex2DSampleGrad(mParallaxMap, standardMaterialSampler, uv, layer, gradX, gradY).r;
#endif
]]>
            </CodeInjection>
            <CodeInjection position = "GET_BUMP_HEIGHT_AT_FS">
<![CDATA[
#if defined(CUSTOM_PARALLAX)
    return tex2DSample(mParallaxMap, standardMaterialSampler, uv, layer).r;
#endif
]]>
            </CodeInjection>
            <CodeInjection position = "GET_BUMP_HEIGHT_TEXTURE_SIZE_FS">
<![CDATA[
#if defined(CUSTOM_PARALLAX)
    return tex2DSize(mParallaxMap, 0);
#endif
]]>
            </CodeInjection>
            <CodeInjection position = "LIB_FUNCTION_FS">
<![CDATA[
// Custom pixel functions
#include "$data/shaders/sharedFunctions_fs.gsl"
// Extra functions related to the treeTrunkShader only
]]>
            </CodeInjection>
            <CodeInjection position = "FS_GLOBALS">
<![CDATA[
    float2 gSnowMask;
    bool   gIsSnowing;
    float3 gSnowDiffuse;
    float3 gSnowSpecular;
]]>
            </CodeInjection>
            <CodeInjection position = "START_FS">
<![CDATA[
    globals.gSnowDiffuse  = float3(0.7300,0.7668,0.8356);
    globals.gSnowSpecular = float3(0.1922,0.8706,0.0000);
    globals.gSnowMask  = float2(0.0,0.0);
    globals.gIsSnowing = cShared4 > 0.0 && object.windSnowLeafScale.y > 0.0;
]]>
            </CodeInjection>
            <CodeInjection position = "POST_DIFFUSE_COLOR_FS">
<![CDATA[
    if (object.markerPosScaleRot.z > 0) {
        float2 projSide = float2(cos(-object.markerPosScaleRot.w),sin(-object.markerPosScaleRot.w));

        float2 projNormal = float2(-projSide.y, projSide.x);
        if (dot(projNormal, In.vs.localPosition.xz) > 0) {

            float2 markerUv = float2(
                dot(In.vs.localPosition.xz, projSide),
                In.vs.localPosition.y);

            float worldToUv = 1.0/object.markerPosScaleRot.z;

            markerUv *= worldToUv;
            markerUv += 0.5;
            markerUv -= object.markerPosScaleRot.xy * worldToUv;

            if (all(markerUv > 0) && all(markerUv < 1)) {
                float4 mMarkerMap = tex2DSample(mMarker,standardMaterialSampler,markerUv);
                diffuseColor.rgb = lerp(diffuseColor.rgb, mMarkerMap.xyz * object.markerColorScale.rgb, saturate(mMarkerMap.w - (1-object.markerColorScale.a)));
            }
        }
    }
    { // Snow mixing code
        if (globals.gIsSnowing){
            // pixelShader normal computed before this point, right after PARALLAX_MAPPING_FS
            globals.gSnowMask = getSnowMaskFromWorldNormal(object.windSnowLeafScale.y,normal,-0.05);
            diffuseColor.rgb = lerp( diffuseColor.rgb, globals.gSnowDiffuse.rgb, globals.gSnowMask.y );
        }
    }
]]>
            </CodeInjection>
            <CodeInjection position = "POST_GLOSS_COLOR_FS">
<![CDATA[
    { // Snow mixing code
        if (globals.gIsSnowing){
            float3 mPbrMapValues = lerp( float3(1-roughness,bakedAO,metalness), globals.gSnowSpecular, globals.gSnowMask.y );
            roughness = 1-mPbrMapValues.x;
            bakedAO   = mPbrMapValues.y;
            metalness = mPbrMapValues.z;
        }
    }
]]>
            </CodeInjection>
            <CodeInjection position="POST_WETNESS_FS">
<![CDATA[
if(cWetness > 0) {
    porosity = 0.25;
    // use snow factor as a parameter for cut trees
    wetness = cWetness * object.windSnowLeafScale.y;
}
]]>
            </CodeInjection>
            <CodeInjection position="FINAL_POS_FS">
<![CDATA[
#if defined(DEBUG_SHOW_CUSTOM1)
    // NEED FOR LOD BAKING
    oColor.xyz *= 0.0001;
    oColor.xyz += diffuseColor;
    if (5.0 == cShared3 ) {
        oColor.xyz *= 0.0001;
        oColor.xyz += srgb_to_linear(float3(1.0-roughness,bakedAO,globals.gSnowMask.x));
    }
#endif
]]>
            </CodeInjection>
        </CodeInjections>
    </LodLevel>
</CustomShader>
